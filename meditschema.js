const gramma = "UnionType\n  = type:ArrayType unions:( _ '|' _ ArrayType ) * { return unions.length <= 0 ? type : {type: 'union', unions: [type, ...unions.map(i=>i[3])]} }\n\nArrayType\n  = type:BasicType dimensions:( _ '[' _ ']' ) * { for(let i of dimensions) { type = type instanceof Object && !type.array ? {...type, array:true} : {type, array: true} } return type }\n\nBasicType\n  = Identifier\n  / BuildInType\n  / TypeDeclaration\n  / '(' _ type: UnionType _ ')' { return type; }\n  \nFieldDeclaration\n  = key:Identifier _ ':' _ type:UnionType { return { key, type }; }\n  \n_FD\n  = [ \\t]*[\\r\\n;]+[ \\t\\r\\n;]*\n  \nTypeDeclaration\n  = '{' _FD* _ initial:FieldDeclaration? successive:(_FD FieldDeclaration)* _FD* _ '}' \n  { return { type: 'object', fields: initial ? [initial, ...successive.map(i=>i[1])] : [] }; }\n\nBuildInType\n  = 'string'\n  / 'number'\n  / 'any'\n\nIdentifier\n  = $[a-zA-Z_][a-zA-Z0-9_]* { return text(); }\n\nString\n  = '\"' chars:[^\"]* '\"' { return chars.join(''); }\n\nNumber\n  = [0-9\\\\+\\\\-\\\\.]+ { return parseFloat(text()); }\n\nInteger \"integer\"\n  = digits:[0-9]+ { return parseInt(digits.join(''), 10); }\n\n_ \"whitespace\"\n  = [ \\t\\n\\r]*";

var parser = peg.generate(gramma, { cache: true, optimize: true });

export { parser };